/*
$HOME/bin_coroutines/bin/g++ -std=c++17 -fcoroutines -I$HOME/gcc_coroutines/gcc/testsuite/g++.dg/coroutines -o co-ret-void-is-ready co-ret-void-is-ready.C
*/

#include "coro.h"

namespace coro = std::experimental::coroutines_n4775;

/* just to avoid cluttering dump files. */
extern "C"
{
  int puts(const char *);
  int printf(const char *, ...);
  void abort() __attribute__((__noreturn__));
}

#ifndef OUTPUT
#  define PRINT(X)
#else
#  define PRINT(X) puts(X)
#endif

struct coro1
{
  struct promise_type;
  using handle_type = coro::coroutine_handle<coro1::promise_type>;
  handle_type handle;

  coro1()
  : handle(0)
  {}

  coro1(handle_type _handle)
  : handle(_handle)
  {
    PRINT("Created coro1 object from handle");
  }

  coro1(const coro1&) = delete;

  coro1(coro1&& s)
  : handle(s.handle)
  {
    s.handle = nullptr;
    PRINT("coro1 move ctor ");
  }

  coro1&
  operator=(coro1 &&s)
  {
    handle = s.handle;
    s.handle = nullptr;
    PRINT("coro1 op = ");
    return *this;
  }

  ~coro1()
  {
    PRINT("Destroyed coro1");
    if (handle)
      handle.destroy();
  }

  struct suspend_never_prt
  {
    bool
    await_ready() const noexcept
    { return true; }

    void
    await_suspend(handle_type) const noexcept
    { PRINT("susp-never-susp"); }

    void
    await_resume() const noexcept
    { PRINT("susp-never-resume"); }

    ~suspend_never_prt()
    {};
  };

  struct suspend_always_prt
  {
    bool
    await_ready() const noexcept
    { return false; }

    void
    await_suspend(handle_type) const noexcept
    { PRINT("susp-always-susp"); }

    void
    await_resume() const noexcept
    { PRINT("susp-always-resume"); }
  };


  struct promise_type
  {
    promise_type()
    { PRINT("Created Promise"); }

    ~promise_type()
    { PRINT("Destroyed Promise"); }

    coro1
    get_return_object()
    {
      PRINT("get_return_object: from handle from promise");
      return coro1(handle_type::from_promise(*this));
    }

    auto
    initial_suspend()
    {
      PRINT("get initial_suspend (never) ");
      return suspend_never_prt{};
    }

    auto
    final_suspend()
    {
      PRINT("get final_suspend (always) ");
      return suspend_always_prt{};
    }

    void
    return_void()
    { PRINT("return_void()"); }

    // Placeholder to satisfy parser, not doing exceptions yet.
    void
    unhandled_exception()
    { /*exit(1);*/ }
  };
  //int x;
};

inline coro1
f() noexcept
{
  PRINT("coro1: about to return");
  co_return;
}

int
main()
{
  PRINT("main: create coro1");
  coro1 x = f ();
  PRINT("main: got coro1 - should be done");
  if (!x.handle.done())
    {
      PRINT("main: apparently was not done...");
      abort();
    }
  PRINT("main: returning");
  return 0;
}
